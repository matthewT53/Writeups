# Feed_me:

## Protections:
* NX + CANARY + PIE

## Binary notes:
* The program generates three random numbers, all of which have been negative
so far and then asks the user for a string of input.
* The string of input should contain three integers that will be converted
to actual integers through the function atoi().

## Exploit notes:
* rand_int_1, rand_int_2 and rand_int_3 are the random 32-bit integers that are
generated by the program.
* str := "x y z" is the input that the user must supply. x,y,a are also 32 bit
integers.
* The distance between each integer in memory is 10 bytes which basically means
only 10 digits can be passed in for each number.
* Also the program ensures the string input only contains digits or dashes.
i.e '0'..'9' or '-'
* There are three constraints that must be satisfied for the flag to be printed:
  1. x + y = rand_int_1
  2. y + z = rand_int_2
  3. x + z = rand_int_3
* Need to use an SAT solver to find values for x,y,z that satisfy these
conditions.
* We shall use z3-solver.

### Input problems:
* Since our numbers can't have more than 10 digits (10 byte max), we need to
construct our numbers in such a way that the program's filter will be happy.
* The integers returned by the solver are all unsigned values and have at
least 10 digits.

If we feed them into the program one after the other, the first call to atoi()
will treat all three numbers as one and will return -1.

e.g 4213123213123124124124124124124124124

So we need a way to seperate the numbers such that each number is given to the
appropriate atoi() call.

You might think why not use a space? Well, if we seperate each number by a space
at the input then scanf() will only take the first number.

After experimenting with the minus signs and adding paddding, I realised that
a minus sign is a good way to seperate the numbers. Zero padding is used to
preserve the negative numbers.

As a result three more constraints are added to the SAT solver.
x > 0, y > 0 and z > 0.

After adding these constraints the solver still returns large unsigned 32-bit
numbers. Not sure how to get z3 to return them as negative numbers.
As a result, we need to convert these numbers to signed 32 bit numbers.

This process is shown below:
1. signed_num = (4294951440 ^ 0xffffffff + 1) * -1
2. We can use the python function format() to add the zero padding between the
'-' and the rest of the numbers to preserve the original number.

## Solution:
1. Extract the three 32 bit numbers generated by the program, r1, r2 and r3.
2. Solve the following equations using the SAT solver.
    x + y = r1 where x > 0 and y > 0
    y + z = r2 where y > 0 and z > 0
    x + z = r3 where x > 0 and z > 0

    where x, y and z are the three numbers to send as input into the program.
3. Convert x, y and z to signed 32 bit numbers and zero pad them if necessary.
4. Send these numbers into the program and hopefully a flag appears.

Note: May take several attempts until a flag is printed.

## Scripts used:
```js
  See exploit.py
```

# Flag:
pctf{p1zz4_t0pp3d_w1th_p1n34ppl3_s4uc3}
