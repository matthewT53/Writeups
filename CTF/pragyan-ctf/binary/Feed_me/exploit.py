#!/usr/bin/env python

from pwn import *
from z3 import *
import re

def recv_response(p):
    r = p.recv()
    print ("[+] Response: " + r)
    return r

# Extracts the strings representing the numbers that the program
# generated and convert these strings to integers.
# These integers are returned in a list.
def extract_numbers(response):
    response = response.lstrip()
    numbers = re.split(r"\s+;\s+", response)
    numbers = numbers[:-1]
    return list(map(lambda x: int(x), numbers))

# Converts an unsigned 32 bit integer to a signed 32 bit integer.
def convert_unsigned_to_signed(unsigned_num):
    signed_num = (unsigned_num ^ 0xffffffff) + 1
    return signed_num * -1

#p = process("./challenge1")
p = remote("159.89.166.12", 9800)

tmp = p.recvuntil("Can you cook my favourite food using these ingredients :)")

# receive and extract the 3 numbers
r = recv_response(p)

random_numbers = extract_numbers(r)
print "[+] Random numbers extracted: " + str(random_numbers)

r1 = random_numbers[0]
r2 = random_numbers[1]
r3 = random_numbers[2]

x, y, z = BitVecs("x y z", 32)

s = Solver()
s.add(x < 0, y < 0, x + y == r1)
s.add(y < 0, z < 0, y + z == r2)
s.add(x < 0, z < 0, x + z == r3)

if s.check():
    print "[+] Solution exists! "
    m = s.model()

    print "[+] Solution: "
    print "\t[+] x = " + str(m[x])
    print "\t[+] y = " + str(m[y])
    print "\t[+] z = " + str(m[z])

x = int(str(m[x]))
y = int(str(m[y]))
z = int(str(m[z]))

x = convert_unsigned_to_signed(x)
y = convert_unsigned_to_signed(y)
z = convert_unsigned_to_signed(z)

buf = "{:010d}".format(x)
buf += "{:010d}".format(y)
buf += "{:010d}".format(z)

print "[+] Sending: " + buf
#gdb.attach(p)

p.sendline(buf)

recv_response(p)

p.interactive()
